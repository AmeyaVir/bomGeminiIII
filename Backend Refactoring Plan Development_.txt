Architectural Analysis and Refactoring Strategy: Resolving Dependencies and Decoupling Components




1. Executive Summary


This report provides a comprehensive architectural analysis of the software system, identifying two critical design flaws that compromise its integrity, maintainability, and scalability. The first is a complex circular dependency involving the KnowledgeBaseService, WorkflowService, and GeminiAgentService. The second is a manifestation of tight coupling, where the DocumentParser is explicitly and rigidly tied to the GeminiAgentService. These issues are not mere coding errors; they are symptoms of a fundamental breakdown in core software design principles.
The recommended solution is a phased refactoring strategy. The immediate tactical fix will involve implementing the Dependency Inversion Principle (DIP) and Dependency Injection (DI) to break the problematic circular imports and decouple the components at a foundational level. The long-term architectural vision formalizes the WorkflowService as a centralized Orchestrator to manage the business logic and workflow, thereby liberating individual services from complex interdependencies. This transformation will be guided by the Strangler Fig Pattern, an incremental and low-risk approach to migrating functionality without disrupting the live system. This strategy will result in a more modular, flexible, and robust codebase, enabling independent development, easier testing, faster feature delivery, and greater resilience against cascading failures.


2. In-Depth Analysis of Design and Code Quality Issues




2.1. The Circular Dependency Triad: KnowledgeBaseService, WorkflowService, and GeminiAgentService


The analysis reveals a complex and fragile dependency graph that creates a circular relationship within the system. As the query notes, the KnowledgeBaseService imports and depends on the GeminiAgentService, while the WorkflowService imports and depends on both the KnowledgeBaseService and the GeminiAgentService. The WorkflowService is responsible for explicitly initializing the GeminiAgentService instance, but the KnowledgeBaseService constructor also allows for an optional GeminiAgentService instance. This creates a confusing and problematic situation.
This dependency structure is a classic example of a system trapped in "Dependency Hell".1 A circular dependency means that if one service in the circle fails or slows down, the others are likely to follow, leading to a cascading failure that can bring the entire system to a halt.1 Such a design also creates significant challenges during deployment, as components must be deployed in a specific, often convoluted, order.1 Furthermore, testing a single service becomes an arduous task. For instance, it is impossible to test the
KnowledgeBaseService in isolation without either the real or a mocked version of the GeminiAgentService.1
The ambiguity of the optional GeminiAgentService instance in the KnowledgeBaseService constructor is a strong indicator of a deeper design problem: a violation of the Single Responsibility Principle (SRP).2 The SRP dictates that a class should have only one reason to change.2 The core responsibility of the
KnowledgeBaseService is to manage and interact with a knowledge base. However, by accepting an optional dependency on an AI agent and potentially making decisions about its use, the service is taking on responsibilities that rightly belong to the higher-level business logic. The WorkflowService is intended to orchestrate the flow of data, but the KnowledgeBaseService's own management of an AI agent blurs the lines and introduces this redundant, cyclical logic. This dual responsibility is the root cause of the confusing dependency structure and is a direct consequence of a failure to separate concerns.


2.2. Tight Coupling: DocumentParser and GeminiAgentService


The analysis also identifies a case of tight coupling, where the DocumentParser's parse_item_master method directly takes the gemini_service as an argument. The query points out that a comment in the code justifies this by stating it is to "avoid a circular dependency." This is an explicit admission that a workaround was implemented to solve a symptom, but it resulted in a new and equally problematic design flaw.
This approach creates a rigid connection between two components that should ideally be independent. The primary function of the DocumentParser should be to parse documents, not to be concerned with the specific details of a particular AI service. By directly requiring the gemini_service, the parser becomes inextricably linked to a specific implementation. This violates the principle of loose coupling, which is a cornerstone of modern software architecture.4 Such a design makes the
DocumentParser difficult to test independently and impossible to reuse in any context that does not involve the Gemini service.2 The tight coupling is a negative consequence of an attempt to "paper over" the original circular dependency problem rather than address it at a deeper architectural level. It indicates a fundamental lack of an abstraction layer, which is the key to creating a flexible and modular system.


2.3. Table: Problem Analysis and Core Principles Violated




Problem
	Description
	Principle Violated
	Impact
	Circular Dependency
	KnowledgeBaseService and WorkflowService depend on each other, mediated by GeminiAgentService.
	Dependency Inversion Principle (DIP) 6
	Cascading failures, deployment nightmares, difficult testing.1
	Tight Coupling
	DocumentParser's parse_item_master directly depends on a concrete gemini_service instance.
	Dependency Inversion Principle (DIP) 6, Single Responsibility Principle (SRP) 2
	Reduced reusability, brittle code, complex testing.2
	

3. The Foundational Principles of Decoupling




3.1. Dependency Inversion Principle (DIP): The Guiding Philosophy


The Dependency Inversion Principle (DIP) is a foundational philosophy for building decoupled and maintainable systems. Its core tenet, as articulated by Robert C. Martin, is that "high-level modules should not depend on low-level modules; both should depend on abstractions. Abstractions should not depend on details; details should depend upon abstractions".7
In the context of the identified issues, the WorkflowService is a high-level module because it defines a critical business process. The DocumentParser and GeminiAgentService are low-level modules because they contain the specific implementation details for their respective tasks. The current design inverts this relationship, with high-level logic tied directly to low-level implementations. The solution is to introduce interfaces or abstract classes that serve as the abstraction layer, allowing both the WorkflowService and the low-level services to depend on a common contract rather than on each other.6 For instance, by defining an
AbstractAgentService interface, the DocumentParser would no longer be concerned with a concrete GeminiAgentService. It would simply depend on the abstract concept of an "Agent" that can perform a specific function. This simple change immediately breaks the tight coupling and opens the door for a more flexible, swappable architecture.


3.2. Dependency Injection (DI): The Practical Implementation of DIP


Dependency Injection (DI) is a specific design pattern that provides a practical mechanism for implementing the Dependency Inversion Principle.9 Instead of modules creating their own dependencies internally, dependencies are "injected" from the outside.10 This approach makes components more loosely coupled and significantly easier to test, as dependencies can be easily mocked or substituted.10
For the current system, DI would be implemented by refactoring the WorkflowService to receive instances of the KnowledgeBaseService and the GeminiAgentService through its constructor. Similarly, the DocumentParser's parse_item_master method could be refactored to accept an instance of an AbstractAgentService. While the provided snippets showcase manual DI, where dependencies are explicitly passed in at runtime 7, at scale, this practice often evolves into the use of an Inversion of Control (IoC) Container.11 An IoC container automates the process of "wiring" and assembling the object graph, transferring control of object creation from the application code to a framework.11 The
WorkflowService can be conceptualized as the de-facto IoC Container for this specific workflow, responsible for assembling the required components and ensuring they are properly connected before execution.12


4. Architectural Patterns for Decomposing Functionality




4.1. The Orchestrator Pattern: Centralizing the Business Workflow


The Orchestrator pattern provides a powerful solution for coordinating complex, multi-step workflows. It involves a central component, the orchestrator, that manages the sequence and execution of multiple, individual services to achieve a specific goal.13 This pattern is an ideal fit for refactoring the
WorkflowService.
By formalizing the WorkflowService as an orchestrator, it assumes the responsibility of containing the core business logic. It would be responsible for:
1. Instantiating the necessary services, such as the DocumentParser, the GeminiAgentService, and the KnowledgeBaseService.
2. Calling the DocumentParser and passing in the GeminiAgentService as a dependency.
3. Receiving the output from the DocumentParser.
4. Passing that output to the KnowledgeBaseService to complete the workflow.
This approach resolves the circular dependency by making the orchestrator the sole coordinator of the flow. The individual services—the DocumentParser and the KnowledgeBaseService—become truly autonomous. They do not need to know about each other; they only need to expose a clear interface that the orchestrator can call.13 The business logic is centralized within the orchestrator, making it easier to understand, manage, and modify without affecting the individual services.13


4.2. Service-Oriented Architecture (SOA) and Microservices


The internal code quality issues identified in the system are a microcosm of larger, architectural problems often found in monolithic applications.15 The tight coupling and circular dependencies are classic symptoms of a system that has grown organically without a well-defined architectural framework. While a full transition to a microservices architecture may not be the immediate goal, applying the core principles of Service-Oriented Architecture (SOA) is essential.4
SOA is built on principles such as loose coupling, service abstraction, and reusability, which are the long-term objectives of this refactoring effort.4 The refactored
DocumentParser, KnowledgeBaseService, and GeminiAgentService can be thought of as embryonic services with clearly defined APIs and contracts.1 Adopting these principles at the module level will prepare the system for future scalability and technology diversity, enabling different teams to work on different components simultaneously and accelerating the time-to-market for new features.3


4.3. Table: Architectural Pattern Comparison




Pattern
	Key Characteristic
	Best For
	Trade-off
	Orchestration 13
	Centralized control via a single orchestrator.
	Complex, synchronous workflows with a clear sequence of steps.
	The orchestrator can become a single point of failure and a scalability bottleneck.14
	Choreography 14
	Decentralized, event-driven communication.
	Simple workflows where services can act independently.
	Lack of centralized visibility and control can make debugging difficult.14
	Mediator 16
	A central object that manages communication between a group of "colleague" objects.
	Reducing many-to-many interactions within a subsystem.
	The mediator can become overly complex if not carefully managed.16
	

5. Strategic Refactoring Recommendations: A Phased Approach




5.1. The Strangler Fig Pattern: A Safe, Incremental Migration


Instead of attempting a risky "Big Bang" rewrite, which often fails to deliver on its promises 18, this refactoring will follow the
Strangler Fig Pattern.20 This pattern provides an incremental, low-risk process for modernization. A new system, or in this case, a new architectural layer, is gradually built around the old system, taking over functionality until the old system is “strangled” and can be safely removed.20 The existing system remains live and functional throughout the entire process, mitigating disruption and risk.21 The
WorkflowService will act as a facade or proxy, intercepting requests and routing them to the new, orchestrated logic.


5.2. Phase 1: Immediate Tactical Decoupling


The primary objective of this phase is to resolve the most pressing issues—the circular dependency and tight coupling—by applying the Dependency Inversion Principle.
The first activity involves creating an abstraction layer for the AI agent. An abstract base class or interface, such as AbstractAgentService, will be defined to specify the contract for an AI service, including a method for column standardization. The existing GeminiAgentService will then be refactored to implement this new interface.7 This is a crucial step that moves the dependency from a concrete implementation to an abstraction.
Next, the DocumentParser will be refactored to use Dependency Injection. Its parse_item_master method will be modified to accept an instance of the newly created AbstractAgentService interface. This single change breaks the tight coupling between the parser and the specific GeminiAgentService implementation, making the DocumentParser reusable and independently testable with mock objects that also implement the interface.2 Finally, the
KnowledgeBaseService will be refactored to depend on an injected AbstractAgentService instance, eliminating the ambiguity of its optional constructor parameter.


5.3. Phase 2: Implementing the Orchestrator


The objective of this phase is to formalize the WorkflowService's role as the central orchestrator of the business logic. While the WorkflowService is already acting as a de-facto assembler of the components, this phase will formalize and centralize that role, creating a more explicit and transparent workflow.
The core activity will be to refactor the WorkflowService to contain the entire business logic flow. This service will be responsible for instantiating the DocumentParser, the KnowledgeBaseService, and the GeminiAgentService. It will then call the DocumentParser's method, explicitly passing in the GeminiAgentService instance via dependency injection. The output will be received and passed to the KnowledgeBaseService, completing the orchestrated flow. By centralizing the creation and injection of dependencies, the WorkflowService acts as the Inversion of Control container for this part of the system.11 The individual services will no longer be aware of each other; they will only be aware of the orchestrator that calls them in the correct sequence.


5.4. Phase 3: Long-Term Architectural Evolution with Strangler Fig


With the immediate issues resolved, the final phase involves a long-term strategy for continued architectural evolution. The Strangler Fig pattern provides the perfect framework for this ongoing process.19
The WorkflowService will continue to act as a façade, routing requests to the new, orchestrated workflow while the old, tightly coupled system remains in place. The next activity would be to identify a component, such as the DocumentParser, and extract it into a standalone service with its own API.19 The
WorkflowService would then communicate with this new service through a standardized contract.4 This process is then repeated for other components, such as the
KnowledgeBaseService. As functionality is migrated to these new services, the original monolith-like code is "strangled" and can be safely removed.21 This iterative approach allows different teams to work on separate parts of the system simultaneously, accelerating development and reducing friction.


5.5. Table: Phased Refactoring Plan


Phase
	Objective
	Key Activities
	Expected Outcomes
	1. Immediate Tactical Decoupling
	Eliminate circular imports and tight coupling.
	Create abstractions, apply constructor DI.
	Improved testability, code is loosely coupled.
	2. Implementing the Orchestrator
	Formalize WorkflowService as the central coordinator.
	Centralize business logic, remove redundant dependencies.
	Clear workflow management, enhanced maintainability.
	3. Long-Term Architectural Evolution
	Incrementally migrate to a service-oriented architecture.
	Apply Strangler Fig pattern, extract services.
	Scalable and resilient system, faster feature delivery.
	

6. Implementation Best Practices and Risk Mitigation




6.1. Avoiding the "Big Bang" Rewrite


The most important strategic decision is to avoid a "Big Bang" rewrite. The existing system is functional, but fragile. A complete overhaul would halt new feature development, introduce immense risk, and likely result in failure.18 The incremental approach of the Strangler Fig pattern allows the system to remain live and functional throughout the entire process, which is far less risky than a complete rebuild.19


6.2. The Importance of Testing


Comprehensive automated testing is a non-negotiable component of this refactoring effort. As functionality is moved and code is restructured, tests serve as a critical safety net, ensuring that small, incremental changes do not introduce unintended bugs or regressions.22 A robust test suite is the only way to validate that the refactored system behaves identically to the original, thereby mitigating the risk of operational disruption.


6.3. Measuring Success


The success of this refactoring should not be judged solely by technical metrics. While reduced coupling and cleaner code are direct outcomes, the ultimate goal is to generate business value. Success can be measured by key performance indicators (KPIs) such as reduced time-to-market for new features, lower operational costs, and improved system resilience.22 This refactoring effort is a strategic investment in the long-term health and scalability of the product.


7. Conclusion


The identified circular dependencies and tight coupling are not isolated coding errors but symptoms of a flawed architectural design. The current structure is rigid, fragile, and a significant source of technical debt that impedes development velocity and increases operational risk.
By adopting a strategic, phased refactoring approach guided by the Dependency Inversion Principle, the Orchestrator pattern, and the Strangler Fig pattern, the system can be transformed into a more robust, scalable, and maintainable platform. This measured, deliberate approach will first resolve the immediate tactical issues and then set the stage for a long-term architectural evolution. These architectural improvements will yield significant business benefits, including reduced development friction, faster time-to-market, and enhanced system resilience, positioning the system for future growth and innovation.
Works cited
1. Circular Dependencies: The Hidden Killer Of Your Microservices! Fix It NOW., accessed September 5, 2025, https://dev.to/xuan_56087d315ff4f52254e6/circular-dependencies-the-hidden-killer-of-your-microservices-fix-it-now-3goi
2. How to refactor a tightly - coupled codebase? - Blog, accessed September 5, 2025, https://www.hlt-cnc.com/blog/how-to-refactor-a-tightly-coupled-codebase-927363.html
3. Monolith to microservices: Breaking down apps the useful way | Red Hat Developer, accessed September 5, 2025, https://developers.redhat.com/articles/2024/01/17/monolith-microservices-breaking-down-apps-useful-way
4. What is Service-oriented Architecture? Benefits & Examples - Port IO, accessed September 5, 2025, https://www.port.io/glossary/service-oriented-architecture
5. What is SOA? - Service-Oriented Architecture Explained - AWS, accessed September 5, 2025, https://aws.amazon.com/what-is/service-oriented-architecture/
6. algocademy.com, accessed September 5, 2025, https://algocademy.com/blog/how-to-handle-circular-dependencies-a-comprehensive-guide/#:~:text=Use%20Dependency%20Inversion%3A%20Implement%20interfaces,the%20likelihood%20of%20circular%20dependencies.
7. From Dependency Inversion to Dependency Injection in Python - DEV Community, accessed September 5, 2025, https://dev.to/markoulis/from-dependency-inversion-to-dependency-injection-in-python-2h70
8. Python Dependency Inversion Principle, accessed September 5, 2025, https://www.pythontutorial.net/python-oop/python-dependency-inversion-principle/
9. Dependency Inversion vs Dependency Injection - Medium, accessed September 5, 2025, https://medium.com/@buketsenturk/dependency-inversion-vs-dependency-injection-4a2dea766e6b
10. How to Handle Circular Dependencies: A Comprehensive Guide - AlgoCademy, accessed September 5, 2025, https://algocademy.com/blog/how-to-handle-circular-dependencies-a-comprehensive-guide/
11. Intro to Inversion of Control and Dependency Injection with Spring - Baeldung, accessed September 5, 2025, https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring
12. Inversion of control - Wikipedia, accessed September 5, 2025, https://en.wikipedia.org/wiki/Inversion_of_control
13. Architectural Patterns | Orchestration Saga Pattern for Microservices | Data Consistency Guide | Gett Tech - Medium, accessed September 5, 2025, https://medium.com/gett-engineering/architectural-patterns-orchestration-saga-0d03894ce9e8
14. Architecture Patterns: Microservices Communication and Coordination - Paradigma Digital, accessed September 5, 2025, https://en.paradigmadigital.com/dev/architecture-patterns-microservices-communication-coordination/
15. What Is Microservices Architecture? - Google Cloud, accessed September 5, 2025, https://cloud.google.com/learn/what-is-microservices-architecture
16. Mediator Pattern. The mediator pattern is a behavioural… | by Sean Bradley | Design Patterns In Python | Medium, accessed September 5, 2025, https://medium.com/design-patterns-in-python/mediator-design-pattern-5b1a8d05b8
17. Difference between Facade and Mediator Design pattern? - Stack Overflow, accessed September 5, 2025, https://stackoverflow.com/questions/30766968/difference-between-facade-and-mediator-design-pattern
18. How to Refactor Complex Codebases – A Practical Guide for Devs - freeCodeCamp, accessed September 5, 2025, https://www.freecodecamp.org/news/how-to-refactor-complex-codebases/
19. Refactoring a Monolith into Microservices - F5, accessed September 5, 2025, https://www.f5.com/company/blog/nginx/refactoring-a-monolith-into-microservices
20. Refactoring Legacy Code with the Strangler Fig Pattern - Shopify, accessed September 5, 2025, https://shopify.engineering/refactoring-legacy-code-strangler-fig-pattern
21. Strangler Fig Pattern - Azure Architecture Center | Microsoft Learn, accessed September 5, 2025, https://learn.microsoft.com/en-us/azure/architecture/patterns/strangler-fig
22. Code Refactoring: Faster Features, Lower Costs, and Unlimited Scalability - DashDevs, accessed September 5, 2025, https://dashdevs.com/blog/code-refactoring/
23. AI-Powered Legacy Code Refactoring: Implementation Guide, accessed September 5, 2025, https://www.augmentcode.com/guides/ai-powered-legacy-code-refactoring